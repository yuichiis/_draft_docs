概要
----

MatrixOperator は、N 次元配列に対する一般的な演算を実行します。ブロードキャスト機能を使用すると、すべての要素に同じ変更を適用できます。
また、乱数生成の機能も提供します。
これらの機能は Python の NumPy に似た設計になっています。

また、柔軟性よりも速度を優先する機能も提供しています。
これらは Basic Linear Algebra Subprograms (BLAS) の一部を抜粋して実装されています。
他の科学計算機能も、必要に応じて実装される予定です。

さらに、純粋な PHP だけでも動作しますが、OpenBLAS や Rindow-Matlib を呼び出して高速に動作させることも可能です。

MatrixOperator の作成
------------------
まず最初に、MatrixOperator のインスタンスを作成します。
（現在のところ、Rindow フレームワークはサポートされていません。）

```php
use Rindow\Math\Matrix\MatrixOperator;
$mo = new MatrixOperator();
```

NDArray の作成
---------
演算を行うために、NDArray 型の配列を作成します。作成方法はいくつかあります。

以下のメソッドを使用できます。

- array
- zeros
- ones
- full
- zerosLike
- fullLike
- arange

```php
$a = $mo->array([1,2,3,4]);
$z = $mo->zerosLike($a);
$x = $mo->zeros([3,5]);
```

配列の演算
---------
Python とは異なり、PHP には演算子オーバーロードの機能がありません。
そのため、すべての演算は MatrixOperator のメソッド を使用して実行します。

```php
$a = $mo->array([1,2,3,4]);
$b = $mo->array([4,3,2,1]);
$c = $mo->op($a,'*',$mo->op($a,'+',$b));
```

ブロードキャスト
---------------
MatrixOperator は、形状が同じ配列の各要素を同じインデックスで演算 します。
異なる形状の配列を演算しようとした場合、小さい方の配列を大きい方に合わせてブロードキャスト します。
データをコピーせずに、メモリ効率よく処理できますが、繰り返し処理が非効率になり、処理速度が低下する場合があります。
高速な数値演算ライブラリ を使用する場合、メモリ消費を犠牲にしてバッチ処理ができるライブラリを検討してください。

#### 同じ形状の配列を演算する例
```php
$a = $mo->array([1.0, 2.0, 3.0]);
$b = $mo->array([10.0, 100.0, 1000.0]);
$c = $mo->op($a, '+', $b);
# [ 11.0,  102.0,  1003.0]
```
#### ブロードキャストを利用する例
```php
$a = $mo->array([
    [[1.0, 2.0],
     [3.0, 4.0]],
    [[5.0, 6.0],
     [7.0, 8.0]]
]);
$b = $mo->array([10.0, 100.0]);
$c = $mo->op($a,'+',$b);
# [[[11.0, 102.0],
#   [13.0, 104.0]],
#  [[15.0, 106.0],
#   [17.0, 108.0]]]
```

一般的なブロードキャストのルール
-----------------------------
ブロードキャストを行うためには、大きい方の配列が小さい方の配列を包含している必要があります。
この動作は NumPy とは異なります ので注意してください。

#### ブロードキャストが可能な例
```php
$a = $mo->array([[1,2],[3,4]]);
$b = $mo->array([1,2]);
$c = $mo->op($a,'+',$b);
## c ==> [[2,4],[4,6]]
```
#### ブロードキャストが不可能な例
```php
$a = $mo->array([1,2,3,4]);
$b = $mo->array([1,2]);
$c = $mo->op($a,'+',$b);
## error
```

スカラー変数との演算は、**すべての要素に対してスカラー変数を適用**します。

```php
$a = $mo->array([[1,2],[3,4]]);
$c = $mo->op($a,'+',2);
## c ==> [[3,4],[5,6]]
```

一般関数の適用
-----------------------------
N 次元配列のすべての要素に特定の関数を適用できます。
```php
$a = $mo->array([[1,4],[9,16]]);
$c = $mo->f('sqrt',$a);
## c ==> [[1,2],[3,4]]
```

無名関数（クロージャ）も使用可能です。
```php
$a = $mo->array([[1,2],[3,4]]);
$c = $mo->f(fn($x)=>$x*2, $a);
## c => [[2,4],[6,8]]
```

配列を直接更新することもできます。

```php
$a = $mo->array([[1,4],[9,16]]);
$mo->u('sqrt',$a);
## a ==> [[1,2],[3,4]]
```

内積と外積
-----------------------------
演算子 `*` や `+` は、内積や外積ではなく、単なる要素ごとの演算 です。
行列の内積や外積を求めるには、`dot` または `cross` を使用 します。

#### 内積（dot product）
```php
$a = $mo->array([1,2,3,4,5,6]);
$b = $mo->array([3,4,5,6,7,8]);
$c = $mo->dot($a,$b);
## c ==> 133
```

#### 外積（cross product）
```php
$a = $mo->array([[1,2,3],[4,5,6],[7,8,9]]);
$b = $mo->array([[2,3,4],[5,6,7],[8,9,1]]);
$c = $mo->cross($a,$b);
## c ==>
##    [[ 36,  42,  21],
##     [ 81,  96,  57],
##     [126, 150,  93]],
```


選択的な操作 (Selective operations)
-----------------------------
データ配列から特定の要素を指定して選択できます。

#### インデックスによる選択
```php
$data = $mo->array(
    [100,101,102,103,104,105,106,107,108,109,110,111],
);
$indexA = $mo->array(
     [2, 1, 0, 3, 4, 5],dtype:NDArray::int32);
$a = $mo->select($data,$indexA);
## a => [102,101,100,103,104,105]

$indexB = $mo->array(
     [[2, 1, 0], [3, 4, 5]],dtype:NDArray::int32);
$b = $mo->select($data,$indexB);
## b => [[102,101,100],[103,104,105]]
```

#### マスクによる選択
Bool型の配列を適用すると、マスクによる選択が可能です。
```php
$data = $mo->array([[-1,2],[-3,4]]);
$mask = $mo->array([[false,true],[false,true]],dtype:NDArray::bool);
$a = $mo->select($data,$mask);
## a =>  [2, 4]

$b = $mo->select($data,$mo->op($data,'>',0));
## b =>  [2, 4]
```

#### 複数のインデックスやマスクを指定
```php
$data = $mo->array(
    [[100,101,102],[103,104,105],[106,107,108],[109,110,111]],
    dtype:NDArray::float32
);
$index0 = $mo->array(
    [2, 0, 3],dtype:NDArray::int32);
$index1 = $mo->array(
    [1, 2, 0],dtype:NDArray::int32);
$a = $mo->select($data,$index0,$index1);
## a => [107, 102, 109]
```

#### 選択した要素の更新
"update" メソッドと更新演算子を使って、選択した要素を更新できます。

```php
$data = $mo->array([[-1,2],[-3,4]]);
$mo->update($data,'=',0,$mo->op($data,'<',0));
## data => [[0,2],[0,4]]
```
```php
$data = $mo->array(
    [[100,101,102],[103,104,105],[106,107,108],[109,110,111]]
);
$index0 = $mo->array(
    [2, 0, 3],dtype:NDArray::int32);
$index1 = $mo->array(
    [1, 2, 0],dtype:NDArray::int32);
$mo->update($data,'+=',1000,$index0,$index1);
## data => [[100,101,1102],[103,104,105],[106,1107,108],[1109,110,111]]
```

行列のコピーと転置 (Copy and transpose matrix)
-----------------------------
"copy" を使用すると、NDArrayとその内部要素データのコピーを作成できます。
"transpose" を使用すると、転置行列に変換した後にコピーを作成できます。

```php
$a = $mo->array([[1,2],[3,4]]);
$b = $mo->copy($a);
## b => [[1,2],[3,4]]

$c = $mo->transpose($a);
## c => [[1,3],[2,4]]
```
集約演算 (Aggregation operations)
-----------------------------
配列要素を集約できます。このとき、集約する次元を指定できます。

#### 集約の種類
- `sum` : 総和
- `asum` : 絶対値の総和
- `max`, `amax`, `argMax`, `argAmax` : 最大値、最大値のインデックス
- `min`, `amin`, `argMin`, `argAmin` : 最小値、最小値のインデックス
- `mean` : 平均

```php
$a = $mo->array([[1,2,3],[4,5,6]]);
$b = $mo->sum($a);
## b => 21

$b = $mo->sum($a,axis:0);
## b => [5,7,9]

$b = $mo->sum($a,axis:1);
## b => [6,15]
```

乱数ライブラリ (Random number library)
-----------------------------
random メソッドを使って、乱数ライブラリを呼び出せます。

- rand : 一様乱数配列
- randn : 正規分布乱数配列
- randomInt : 整数の乱数
- choice : 選択的乱数配列

```php
$a = $mo->random()->rand([2,3]);
## a => [[乱数....]]
```

線形代数ライブラリ (Linear Algebra library)
-----------------------------
柔軟性よりも速度を優先する場合は、線形代数ライブラリを呼び出せます。

ほとんどの関数は、1次元または2次元の配列を想定したアルゴリズムです。
**入力データは破壊され**、出力データの領域として使用されます。
これにより、連続した処理を行う際のデータコピーを最小限に抑えます。

OpenBLAS がロードされている場合、これを呼び出してより高速に動作します。

#### 主な機能
- BLAS ライブラリ
- 数学ライブラリ

詳しくは[こちら](liearalgebra.html)を参照してください。


```php
$a = $mo->array([[1,2,3],[4,5,6],[7,8,9]]);
$b = $mo->array([[1,0,0],[0,1,0],[0,0,1]]);

$c = $mo->la()->gemm($a,$b);
## c => [[1,2,3],
##       [4,5,6],
##       [7,8,9]]
```

文字列化
---------
配列の要素や形状やデータ型は文字列化できます。

```php
$a = $mo->array([[1,2,3],[4,5,6],[7,8,9]]);
$printable = $mo->toString($a);
$shape = $mo->shapeToString($a->shape());
$dtype = $mo->dtypeToString($a->dtype());
echo $printable."\n";
echo $shape."\n";
echo $dtype."\n";
# [
#  [1,2,3],
#  [4,5,6],
#  [7,8,9]
# ]
# (3,3)
# float32
```

配列の保存
---------------------
保存用に配列をシリアライズ出来ます。

```php
$a = $mo->array([[1,2,3],[4,5,6],[7,8,9]]);
$persistentable = $mo->serializeArray($a);
file_put_contents(__DIR__."./foo.data",$persistentable);
$loadedArray = file_get_contents(__DIR__."./foo.data");
$b = $mo->unserializeArray($loadedArray);
echo $mo->toString($b)."\n";
# [
#  [1,2,3],
#  [4,5,6],
#  [7,8,9]
# ]
```


その他の機能 (Other functions)
-----------------------------
- astype : データ型のキャスト
- add : 単純な加算
- scale : 定数倍演算

サービスレベル
-------------
`LinearAlegebla`ライブラリは外部ライブラリにリンクして高速な演算を行うことが一般的な使い方ですが、P純粋なPHPだけで動作することも出来ます。

